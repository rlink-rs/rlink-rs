use std::path::PathBuf;
use std::str::FromStr;

use crate::api::cluster::{load_config, ClusterConfig};
use crate::metrics::global_metrics::set_manager_id;
use crate::runtime::{logger, ClusterMode, ManagerType};
use crate::utils;

/// Process run context
/// `cluster_mode`: Empty or `Standalone`, default `Local`, generated by `StandaloneResourceManager`
/// `manager_type`: `Coordinator` or `Worker`, generated by `StandaloneResourceManager`
///
/// `Local` and `Coordinator` process args:
///     `bind_ip`: ignore, default with "0.0.0.0"
///     `task_manager_id`: ignore
///     `num_task_managers`: ignore task manager size
///     `cluster_config`: ignore
/// `Local` and `Worker` process args:
///     `bind_ip`: ignore, default with "0.0.0.0"
///     `task_manager_id`: task manager process id, generated by `Coordinator`
///     `num_task_managers`: ignore
///     `cluster_config`: ignore
///
/// `Standalone` mode
///     `Coordinator` process args:
///         `cluster_mode`: must be `Standalone`
///         `manager_type`: must be `Coordinator`
///         `num_task_managers`: task manager size
///         `coordinator_address`: ignore
///         `bind_ip`: coordinator ip, generated by `TaskManager`
///         `job_id`: job id, generated by `JobManager`
///         `task_manager_id`: ignore
///         `cluster_config`: cluster config path, generated by `TaskManager`
///     `Worker` process args:
///         `cluster_mode`: must be `Standalone`
///         `manager_type`: must be `Worker`
///         `num_task_managers`: ignore
///         `coordinator_address`: coordinator address
///         `bind_ip`: worker ip, generated by `TaskManager`
///         `job_id`: job id, same as `Coordinator`
///         `task_manager_id`: task manager process id, generated by `Coordinator`
///         `cluster_config`: cluster config path, generated by `TaskManager`
///
#[derive(Clone, Serialize, Deserialize, Debug)]
pub(crate) struct Context {
    pub application_name: String,
    pub application_id: String,
    /// when `ManagerType::Coordinator`: `job_manager_id`
    /// when `ManagerType::Worker`: `task_manager_id`
    pub task_manager_id: String,
    pub bind_ip: String,
    pub cluster_mode: ClusterMode,
    pub num_task_managers: u32,
    pub manager_type: ManagerType,
    pub cluster_config: ClusterConfig,
    pub metric_addr: String,
    /// effective only in `Worker` mode
    pub coordinator_address: String,

    /// on yarn arg
    pub worker_process_path: String,
    pub memory_mb: usize,
    pub v_cores: usize,
}

impl Context {
    pub fn new(
        application_name: String,
        application_id: String,
        task_manager_id: String,
        bind_ip: String,
        cluster_mode: ClusterMode,
        num_task_managers: u32,
        manager_type: ManagerType,
        cluster_config: ClusterConfig,
        metric_addr: String,
        coordinator_address: String,
        worker_process_path: String,
        memory_mb: usize,
        v_cores: usize,
    ) -> Self {
        Context {
            application_name,
            application_id,
            task_manager_id,
            bind_ip,
            cluster_mode,
            num_task_managers,
            manager_type,
            cluster_config,
            metric_addr,
            coordinator_address,
            worker_process_path,
            memory_mb,
            v_cores,
        }
    }

    pub fn parse_node_arg(job_name: &str) -> Context {
        // let bind_ip = utils::parse_arg("bind_ip").unwrap_or("0.0.0.0".to_string());
        let bind_ip = utils::ip::get_service_ip()
            .expect("get service ip error")
            .to_string();

        let cluster_mode = match utils::parse_arg("cluster_mode") {
            Some(value) => ClusterMode::from(value),
            None => ClusterMode::Local,
        };

        let manager_type = match utils::parse_arg("manager_type") {
            Some(manager_type) => ManagerType::from(manager_type),
            None => ManagerType::Coordinator,
        };

        let job_id = match cluster_mode {
            ClusterMode::Local => utils::gen_id(),
            ClusterMode::Standalone | ClusterMode::YARN => {
                utils::parse_arg("job_id").expect("`job_id` not found")
            }
        };

        let task_manager_id = match manager_type {
            ManagerType::Coordinator => "coordinator".to_string(),
            ManagerType::Standby => "standby".to_string(),
            ManagerType::Worker => {
                utils::parse_arg("task_manager_id").expect("`task_manager_id` not found")
            }
        };
        set_manager_id(task_manager_id.as_str(), bind_ip.as_str());

        let num_task_managers = match manager_type {
            ManagerType::Coordinator => match cluster_mode {
                ClusterMode::Local => 1,
                ClusterMode::Standalone | ClusterMode::YARN => {
                    let num_task_managers = utils::parse_arg("num_task_managers")
                        .expect("`num_task_managers` argument is not found");
                    let num_task_managers = u32::from_str(num_task_managers.as_str())
                        .expect("parse `num_task_managers` to u32 error");
                    if num_task_managers < 1 {
                        panic!("`num_task_managers` must the [value > 1]")
                    }
                    num_task_managers
                }
            },
            _ => 0,
        };

        let cluster_config = match cluster_mode {
            ClusterMode::Local => match utils::parse_arg("cluster_config") {
                Some(cluster_config) => load_config(PathBuf::from(cluster_config)),
                None => ClusterConfig::new_local(),
            },
            ClusterMode::Standalone => {
                let cluster_config = utils::parse_arg("cluster_config")
                    .expect("`cluster_config` argument is not found");
                load_config(PathBuf::from(cluster_config))
            }
            ClusterMode::YARN => ClusterConfig::new_local(),
        };

        let (worker_process_path, memory_mb, v_cores) = match cluster_mode {
            ClusterMode::YARN => match manager_type {
                ManagerType::Coordinator => {
                    let worker_process_path = utils::parse_arg("worker_process_path")
                        .expect("`worker_process_path` argument is not found");

                    let memory_mb =
                        utils::parse_arg("memory_mb").expect("`memory_mb` argument is not found");
                    let memory_mb = usize::from_str(memory_mb.as_str())
                        .expect("parse `memory_mb` to usize error");

                    let v_cores =
                        utils::parse_arg("v_cores").expect("`v_cores` argument is not found");
                    let v_cores =
                        usize::from_str(v_cores.as_str()).expect("parse `v_cores` to usize error");

                    (worker_process_path, memory_mb, v_cores)
                }
                _ => ("".to_string(), 0, 0),
            },
            _ => ("".to_string(), 0, 0),
        };

        logger::init_log(&cluster_mode, "info");

        let metric_addr = metrics_serve(bind_ip.as_str(), &cluster_mode, &manager_type);

        let coordinator_address = match manager_type {
            ManagerType::Coordinator => "".to_string(),
            _ => utils::parse_arg("coordinator_address")
                .expect("`coordinator_address` argument is not found"),
        };

        Context::new(
            job_name.to_string(),
            job_id,
            task_manager_id,
            bind_ip,
            cluster_mode,
            num_task_managers,
            manager_type,
            cluster_config,
            metric_addr,
            coordinator_address,
            worker_process_path,
            memory_mb,
            v_cores,
        )
    }
}

fn metrics_serve(bind_ip: &str, cluster_mode: &ClusterMode, manager_type: &ManagerType) -> String {
    let with_proxy = if cluster_mode.clone() != ClusterMode::Local
        && manager_type.clone() == ManagerType::Coordinator
    {
        true
    } else {
        false
    };

    let addr = crate::metrics::init_metrics2(bind_ip, with_proxy);
    format!("http://{}:{}", bind_ip, addr.port())
}
